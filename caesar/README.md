# Caesar

{% video https://youtu.be/LenUBpOdhGk %}

{% next %}

## Et tu?

Кажуть, що Цезар (так, той самий Цезар) зашифровував усі конфіденційні повідомлення (тобто змінював їх таким чином, щоб можна було відновити оригінал) шляхом зсуву кожної букви на кілька кроків. Наприклад, він міг написати A як B, B як C, C як D ... Z як A. А отже, щоб сказати комусь HELLO, Цезар міг написати IFMMP. Після отримання такого повідомлення від Цезаря, отримувачі повинні були «розшифрувати» повідомлення шляхом зсуву літер у зворотньому напрямку на таку саму кількість кроків.

Секретність такої «криптосистеми» полягала у тому, що тільки Цезар і отримувач повідомлення знали цей секрет – кількість кроків, на яку Цезар зсунув літери (наприклад, 1). За нинішніми стандартами, все це не так вже й безпечно, але якщо ви – перша людина у світі, яка займається подібними речами, ще й як безпечно!

Незашифрований текст зазвичай називають _звичайний текст_. Зашифрований текст зазвичай так і називають _зашифрований текст_. Секретна інформація, що використовується при шифруванні, називається _ключем_.

На рисунку нижче зображено, як слово `HELLO` із використанням ключа 1 шифрується у `IFMMP`:

| звичайний текст   | H | E | L | L | O |
|-------------------|---|---|---|---|---|
| + ключ            | 1 | 1 | 1 | 1 | 1 |
| = зашифрований    | I | F | M | M | P |

Якщо говорити загально, алгоритм Цезаря (тобто шифр Цезаря) шифрує повідомлення шляхом «обертання» кожної букви на k позицій. Формальніше, якщо p – якийсь звичайний текст (незашифрованне повідомлення), p<sub>i</sub> – це i-ий символ у p, а k – секретний ключ (тобто невід'ємне ціле число), тоді кожна буква c<sub>i</sub> у зашифрованному тексті c, обраховується так:

c<sub>i</sub> = (p<sub>i</sub> + k) % 26

де `% 26` означає «залишок від ділення на 26». Ця формула, мабуть, робить так, що шифр видається складнішим, ніж насправді, але це лише лаконічна форма точного вираження суті алгоритму. Насправді, задля прикладу, подумайте про А (або а) як про В (або b) як про 1, і так далі, H (або h) як про 7, I (або i) як про 8 і так далі, а Z (або z) як про 25. Уявімо, що Цезар хотів сказати «Hi» комусь конфіденційно, використвавши цього разу ключ k 3. Тож його звичайний текст p – це «Hi», у цьому випадку перша літера його звичайного тексту p<sub>0</sub> – це H (вона ж 7), а друга літера p<sub>1</sub> – це i (вона ж 8). Перша літера зашифрованого тексту c<sub>0</sub>, таким чином K, а друга - c<sub>1</sub>, відповідно L. Розумієте чому?

Давайте напишемо програму під назвою caesar, яка дозволить вам зашифрувати повідомлення шифром Цезаря. Під час запуску програми користувачем, він має обрати за допомогою аргументів командного рядка, яким буде ключ у секретному повідомленні, яке він введе під час роботи програми. Не треба очікувати, що ключем обов’язково буде число, але можна вважати, що якщо це число, то це буде додатне ціле число.

Ось кілька прикладів очікуваної роботи цієї програми. Наприклад, якщо користувач вводить ключ '1' та текст 'HELLO':

```
$ ./caesar 1
plaintext:  HELLO
ciphertext: IFMMP
```

Ось так може працювати програма, якщо користувач введе ключ '13' та текст 'hello, world':

```
$ ./caesar 13
plaintext:  hello, world
ciphertext: uryyb, jbeyq
```

Зверніть увагу, що ані кома, ані пробіл не були «змінені» шифром. Він змінює виключно літерні символи!

Розглянемо ще? Ось так працюватиме програма, якщо користувач введе ключ `13` ще раз, але для складнішого тексту:

```
$ ./caesar 13
plaintext:  be sure to drink your Ovaltine
ciphertext: or fher gb qevax lbhe Binygvar
```

{% spoiler "Чому?" %}

{% video https://youtu.be/pe_yzCzYWs8 %}

{% endspoiler %}

Зверніть увагу, що регістр символів оригінального повідомлення збережено. Літери у нижньому регістрі залишились маленькими, а літери у верхньому регістрі лишились великими.

А якщо користувач не хоче співпрацювати?

```
$ ./caesar HELLO
Usage: ./caesar key
```

Або зовсім не хоче співпрацювати?

```
$ ./caesar
Usage: ./caesar key
```
Або навіть…

```
$ ./caesar 1 2 3
Usage: ./caesar key
```

{% spoiler "Спробуйте" %}

Аби спробувати попрацювати із розв’язком цієї задачі від команди курсу, виконайте:

```
./caesar key
```

передаючи правильне ціле число в якості _ключа_ [ось тут](http://bit.ly/2Vwi8n0).

{% endspoiler %}

Як почати? Давайте розглянемо цю задачу крок-за-кроком.

{% next %}

## Псевдокод

Спочатку напишіть у файлі 'pseudocode.txt' якийсь псевдокод, який імплементує цю програму, навіть якщо ви (поки!) не впевнені, як записати це в коді. Немає якогось правильного єдиного способу писати псевдокод, але короткі речення українською мовою підійдуть. Згадайте, як ми писали псевдокод, щоб [знайти Майка Сміта](https://prometheus.org.ua/cs50_2019/notes0.html#pseudocode). Швидше за все у вашому псевдокоді ви використаєте (або вкажете, що треба використати!) одну або більше функції, умови, булеві вирази, цикли та/або змінні.

{% spoiler %}

Існує кілька способів це зробити, ось один з них!

1. Перевірте, що програму запущено з одним аргументом командного рядка
1. Проітеруйте крізь аргумент, аби впевнитись, що всі символи – це цифри
1. Конвертуйте цей аргумент командного рядка з string на int
1. Запросіть у користувача звичайний текст
1. Проітеруйте крізь кожен символом у звичайному тексті:
    1. Якщо це велика літера, змініть її, зберігши регістр, а потім виведіть змінений символ
    1. Якщо це маленька літера, змініть її, зберігши регістр, а потім виведіть змінений символ
    1. Якщо літера не велика і не маленька, виведіть символ, як є
1. Виведіть новий рядок

Абсолютно нормально, якщо ви захочете відредагувати ваш власний псевдокод, побачивши цей, але не копіюйте і не вставляйте його, наче власний!

{% endspoiler %}

{% next %}

## Підрахунок аргументів командного рядка

Яким би не був ваш псевдокод, давайте спочатку напишемо просто код на С, який перевіряє, чи була програма запущена з єдиним аргументом командного рядка перед тим, як додавати функціональність.

А саме – змініть `caesar.c` таким чином, що якщо користувач введе лише один аргумент командного рядка, буде виведено `Success;` якщо користувач не введе жодного аргументу командного рядка або введе два чи більше, буде виводитись `Usage: ./caesar key`. Пам’ятайте, оскільки ключ вводиться з командного рядка під час запуску програми, а не через `get_string`, у нас немає можливості ще раз запитати користувача. Поведінка програми, яка вийде в результаті, має бути такою:

```
$ ./caesar 20
Success
```

чи

```
$ ./caesar
Usage: ./caesar key
```

чи

```
$ ./caesar 1 2 3
Usage: ./caesar key
```

{% spoiler "Підказка" %}

* Пам’ятайте, що можете скомпілювати програму за допомогою `make`.
* Пам’ятайте, що можете вивести дані на екран за допомогою `printf`.
* Пам'ятайте, що `argc` та `argv` дають вам інформацію про те, що було введено у командному рядку.
* Пам’ятайте, що саме ім’я програми (в даному випадку, це `./caesar`) знаходить у `argv[0]`.

{% endspoiler %}

{% next %}

## Доступ до ключа

Тепер, коли ваша програма (сподіваємось!) приймає вхідні дані, як і передбачалось, настав час наступного кроку.

Пам’ятайте, що у нашій програмі ми повинні захищатись від користувачів, які технічно вводять єдиний аргумент командного рядка (ключ), але вводять щось, що не є цілим числом, наприклад:

```
$ ./caesar xyz
```

Перед тим, як розпочати аналіз ключа на валідність, впевніться, що ми справді зможемо його зчитати. Змініть знову caesar.c так, аби програма перевіряла не тільки те, що користувач ввів єдиний аргумент командного рядка, а й після перевірки цього виводила цей єдиний аргумент командного рядка. Тож, наприклад, програма має поводитись ось так:

```
$ ./caesar 20
Success
20
```

{% spoiler "Підказка" %}

* Пам’ятайте, що `argc` та `argv` дають вам інформацію про те, що було введено у командному рядку.
* Пам’ятайте, що `argv` - це масив рядків.
* Пам’ятайте, що з `printf` ми можемо вивести рядок, використавши `%s` як місцезаповнювач.
* Пам’ятайте, що фахівці з комп’ютерних наук полюбляють рахувати з нуля `0`.
* Пам’ятайте, що ми можемо одержати доступ до окремого елемента масиву, такого як `argv` використавши квадратні дужки, наприклад: `argv[0]`.

{% endspoiler %}

{% next %}

## Валідація ключа

Тепер, коли ви знаєте, як читати ключі, давайте проаналізуємо їх. Змініть `caesar.c` так, аби замість виведення наданого аргументу командного рядка ваша програма перевіряла, що кожен символ серед аргументів командному рядку – це десяткове число (тобто `0, 1, 2` і т. ін.) та якщо хоча б один із них таким не є, завершувалася після виведення повідомлення `Usage: ./caesar key`. Але якщо серед аргументів тільки цифри, ви маєте конвертувати (пам’ятайте, що `argv` - це масив рядків, навіть якщо ці рядки виглядають як числа) на цілі числа та вивести ціле число за допомогою `%i` у `printf`. Наприклад, поведінка має виглядати так:

```
$ ./caesar 20
Success
20
```

чи

```
$ ./caesar 20x
Usage: ./caesar key
```

{% spoiler "Підказки" %}

* Пам’ятайте, що `argv` - це масив рядків.
* Пам’ятайте, що рядок, водночас, це просто масив символів типу `char`.
* Пам’ятайте, що заголовковий файл `string.h` містить корисні функції, які працюють з рядками.
* Пам’ятайте, що ми можемо використати цикл, аби проітерувати крізь кожен символ рядка, якщо ми знаємо розмір рядка.
* Пам’ятайте, що заголовковий файл `ctype.h` містить корисні функції, які надають інформацію про символи.
* Пам’ятайте, що ми можемо за допомогою `return` повертати ненульові значення з `main` щоб вказати, що наша програма не завершилась успішно.
* Пам’ятайте, що з `printf` ми можемо вивести ціле число за допомогою %i як місцезаповнювача.
* Пам’ятайте, що функція `atoi` конвертує рядки, які виглядають як числа на справжні числа.

{% endspoiler %}

{% next %}

## Заглядаємо «під капот»

юдям легко інтуїтивно зрозуміти описану вище формулу, ми б могли просто сказати «H + 1 = I». Але чи може комп'ютер зрозуміти ту саму логіку? Давайте дізнаємось. Зараз тимчасово будемо ігнорувати ключі від користувача, а замість них будемо запитувати користувача про секретне повідомлення та намагатись посунути всі символи на один.

Розширте функціональність `caesar.c` так, аби після валідації ключа ми запитували у користувача рядок, а потім посунули всі символи на один, після чого вивели результат. На цьому етапі ми також можемо, мабуть, прибрати рядок коду, який ми раніше написали та який виводив `Success`. Після всього цього у результаті програма має поводитись так:

```
$ ./caesar 1
plaintext:  hello
ciphertext: ifmmp
```

{% spoiler "Підказка" %}

* Спробуйте проітерувати через кожен символ у звичайному тексті та буквально додавати по 1 символу до них і виводити це.
* Якщо `c` - це змінна типу `har` у C, що станеться, коли ви викличете `printf("%c", c + 1)`?

{% endspoiler %}

{% next %}

## Ваша черга

Настав час зв’язати все разом! Замість того, щоб посувати символ на 1, змініть `caesar.c` так, щоб вони зміщувались на справжнє значення ключа. І впевніться, що ви зберегли регістр! Великі літери мають залишитись великими, маленькі літери мають залишитись маленькими, а нелітерні символи мають залишитись без змін.

{% spoiler "Підказки" %}

* Краще використовувати остачу від ділення (тобто залишок) %, аби впоратись з заокругленням від Z до A! Але як?
* Все стає дуже дивним, коли ми намагаємось перевернути Z чи z на 1 з використанням методів із минулого підрозділу.
* Все також стає дуже дивним, якщо ми намагаємось змінити пунктуаційні знаки за допомогою такого ж методу.
* Пам’ятайте, що ASCII ставить всі символи, які можна вивести, у відповідність до чисел.
* Пам’ятайте, що значення ASCII для A - 65. Значення ASCII для a, водночас, 97.
* Якщо ви не бачите жодного виводу, коли викликаєте printf, швидше за все це тому, що ви виводите символи за межами валідних для ASCII значень від 0 до 127. Спробуйте спочатку виводити символи як числа (використайте %i замість %c) аби побачити значення, які ви виводите, та впевніться, що ви намагаєтесь вивести валідні символи!

{% endspoiler %}
