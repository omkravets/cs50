# Cash

{% video https://youtu.be/Z9-ektenG-A %}

{% next %}

## «Жадібні» алгоритми

<!-- http://mypieceofthe31415927.blogspot.com/2014/04/whats-wrong-with-these-us-coins.html -->
![US coins](coins.jpg)

Коли ви даєте решту, то, мабуть, хочете мінімізувати кількість монеток для кожного покупця, бо вони можуть закінчитись, а покупці – розлютитись! На щастя, комп'ютерні науки надали можливість касирам по всьому світу мінімізувати кількість монеток: вони винайшли «жадібні» алгоритми.

Відповідно до National Institute of Standards and Technology (NIST), жадібний алгоритм - це такий алгоритм, який «завжди обирає найкращий миттєвий, чи локальний, розв'язок під час пошуку відповіді. Жадібні алгоритми знаходять глобальний оптимальний розв'язок для деяких задач, але можуть знайти неоптимальний розв'язок для деяких інших задач».

Що все це означає? Припустимо, що касир має видати клієнту решту, і в нього є пристрій, що видає монети у 25, 10, 5 та 1 центи. Для того, щоб розв'язати цю «задачу», касирові потрібно один чи декілька разів натиснути на важелі. «Жадібний» касир із кожним натисканням захоче забрати із потрібної суми максимально можливий обсяг. Наприклад, якщо він винний якомусь клієнтові 41 цент, найбільший (тобто локально-оптимальний) обсяг цієї суми, який можна покрити одним натисканням - це 25 центів (ця сума є «найкращою», тому що вона приводить нас ближче до суми 0 центів швидше, ніж всі інші монетки). Помітимо, що після цієї дії нам тепер потрібно видати не 41 цент, а 16 центів (41 - 25 = 16). А отже, видання такого обсягу здачі - це схожа, але менша за попередню задача. Зрозуміло, що видати ще 25 центів ми не можемо (ця сума буде занадто великою - касир не хоче втрачати гроші!), а, отже, наш жадібний касир візьме монетку розміром 10 центів, що залишить його із рештою видачі на 6 центів. На цьому етапі, жадібність змусить касира видати 5 центів, а потім 1 цент, і після цього задача буде розв'язана. Клієнт отримає по одній монетці на 25, 10, 5 та 1 центи: 4 монетки загалом.

Виявляється, що такий жадібний підхід (тобто алгоритм) є не тільки локально-оптимальним, але і глобально-оптимальним для американських монеток (а також для монеток Європейського Союзу). Тобто, якщо припустити, що у касира достатньо монеток, цей підхід «від більшого до меншого» приведе до найменшої кількості виданих монеток. Скільки саме монеток буде видано для довільної задачі? Що ж, дізнатись це і є вашою задачею!

{% next %}

## Специфікація

Напишіть програму cash.c, яка питатиме у користувача, скільки решти необхідно видати, а потім видає мінімальну кількість монеток, за допомогою яких цей обсяг решти можна видати.

Використовуйте функцію get_float для того, щоб отримати вхідні дані від користувача, та printf, аби вивести ваш результат. Припускайте, що вам доступні монетки номіналом 25, 10, 5 та 1 центи.
Ми просимо вас використовувати get_float sдля того, щоб ви могли працювати з доларами і центами, відкинувши знак долара ($). Іншими словами, якщо певному клієнтові винні $9.75 (наприклад, газета коштувала 25 центів, але клієнт платить 10-доларовою купюрою), припускайте, що на вхід вашій програмі поступить величина 9.75 а не $9.75 чи 975. Якщо певному клієнтові винні 9 доларів рівно, припускайте, що на вхід вашій програмі поступить величина 9.00 чи 9, але, знову ж таки, не $9 або 900. Звичайно, через природу чисел з рухомою комою, ваша програма швидше за все коректно спрацює із вводом 9.0 та 9.000 але вам не потрібно хвилюватись про перевірку того, чи ввід користувача є відформатованим так, як має бути відформатований грошовий ввід.
Вам не потрібно перевіряти, чи вміщаються користувацькі дані у тип даних float. Використання get_float перевірить, чи є вхідні дані дробовими (або ж цілими, що також допустимо для нашої задачі), але не перевірить, чи є вони невід'ємними.
Якщо користувач не вводить невід'ємну суму, ви повинні знову і знову просити його ввести коректну суму доти, доки це не станеться.
Ми хочемо автоматизувати перевірки вашого коду, тож впевніться, що останній рядок виводить лише одне число: мінімальну кількість монеток, після якої виводиться \n.
Остерігайтесь неточності чисел з рухомою комою. Згадайте floats.c з лекції, в котрій якщо x дорівнює 2 і y дорівнює 10, x / y не дорівнює точно дві десятих! Тож, перед тим, як видати решту, варто конвертувати введені долари на центи (тобто з float до int) аби уникнути невеличких помилок, які можуть накопичуватись!
Також пам’ятайте, що потрібно округлити до центів за допомогою round, яка оголошена у бібліотеці math.h. Наприклад, якщо dollars це float з вхідними даними від користувача (наприклад, 0.20), тоді код

  ```
  int coins = round(dollars * 100);
  ```

 безпечно конвертує 0.20 (або навіть 0.200000002980232238769531250) до 20.

Ваша програма має поводитись, як у прикладах нижче.

```
$ ./cash
Change owed: 0.41
4
```

```
$ ./cash
Change owed: -0.41
Change owed: foo
Change owed: 0.41
4
```

{% spoiler "Підказки" %}

{% video https://youtu.be/5G-XKHtXXyQ %}

{% endspoiler %}

### Розв’язок команди курсу

Аби переглянути розв’язки команди курсу для цієї задачі, виконайте:

```
./cash
```

ось [в цьому sandbox](http://bit.ly/2VAxlUr).

### Як протестувати ваш код

Переконайтеся, що ваш код працює так, як описано, коли ви вводите:

-1.00 (або інше від’ємне число)?
0.00?
0.01 (або інше додатне число)?
літери або слова?
нічого не вводите, а просто натискаєте Enter?

