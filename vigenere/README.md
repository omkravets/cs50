# Vigenère

{% video https://youtu.be/qmgr9yJFdXQ %}

{% next %}

## Ooh, la la!

Шифр Віженера є покращенням відносно шифру Цезаря. Шифрування у ньому відбувається шляхом використання _послідовності ключів_ (або _лючового слова_).

Тобто, якщо _p_ – це звичайний текст і _k_ – ключове слово (як, наприклад, алфавітний рядок: де А (або а) представляє 0, B (або b) представляє 1, C (або c) представляє 2, Z представляє с 25), то кожна літера _c<sub>i</sub>_, в зашифрованому тексті _c_ обраховується як:

c<sub>i</sub> = (p<sub>i</sub> + k<sub>j</sub>) % 26

Зауважте, що шифр використовує _k<sub>j</sub>_ проти _k_. І пам'ятайте, що, якщо довжина _k_ менша за довжину _p_, то літери в _k_ мають бути циклічно використані стільки раз, скільки потрібно для шифрування _p_.

Інакше кажучи, якби сам Віженер хотів конфіденційно сказати комусь HELLO із використанням ключового слова, скажемо, ABC, він би зашифрував H за допомогою ключа 0 (тобто A), Е – за допомогою ключа 1 (тобто B), а першу букву L – за допомогою ключа 2 (тобто С). На цьому етапі в нього б закінчились букви у ключовому слові, і тому він знову використав би частину ключового слова, щоб зашифрувати другу L ключем 0 (тобто A), а букву O – ключем 1 (тобто B). Отже, він написав би HELLO як HFNLP, як на рисунку нижче:

| plaintext    | H | E | L | L | O |
|--------------|---|---|---|---|---|
| + key        | A | B | C | A | B |
| (shift value)| 0 | 1 | 2 | 0 | 1 |
| = ciphertext | H | F | N | L | P |

Давайте напишемо програму `vigenere`, яка дозволяє шифрувати повідомлення за допомогою коду Віженера. Під час запуску програми користувачем, він має обрати за допомогою аргументу командного рядка, яким буде ключ у секретному повідомленні, яке він введе під час роботи програми.

Ось кілька прикладів того, як може працювати програма:

```
$ ./vigenere bacon
plaintext:  Meet me at the park at eleven am
ciphertext: Negh zf av huf pcfx bt gzrwep oz
```

або коли користувач вводить ключове слово, але воно не повністю складається з літер:

```
$ ./vigenere 13
Usage: ./vigenere keyword
```

Або коли користувач не вводить ключове слово:

```
$ ./vigenere
Usage: ./vigenere keyword
```

Або коли користувач вводить забагато ключових слів:

```
$ ./vigenere bacon and eggs
Usage: ./vigenere keyword
```

{% spoiler "Спробуйте" %}

Для того, щоб спробувати варіанти розв’язку цієї задачі командою курсу, виконайте%

```
./vigenere keyword
```

Поставте валідний літерний рядок на місце `ключового слова` ось[тут](http://bit.ly/2Qocfog).

{% endspoiler %}

З чого почати? Давайте почнемо з чогось знайомого!

{% next %}

## Déjà vu

Як ви вже, мабуть, зрозуміли, основна ідея цього виду шифрування дуже подібна до ідеї, яка лежить в основі шифрування Цезаря. Отже, наш код у шифруванні Цезаря – це гарний початок, тож можете спокійно спробувати замінити весь вміст `vigenere.c` вашим розв’язком для `caesar.c`. 

Єдина відмінність між шифруваннями Цезаря та Віженера – ключ для шифрування Віженера складається з літер, а не з чисел. Тому треба впевнитись, що користувач насправді введе ключове слово! Змініть перевірку, яку ви імплементували для шифрування Цезаря так, щоб впевнитись, що кожен символ ключового слова літерний, а не цифровий. Якщо якийсь елемент не літерний, програма має виводити `Usage: ./vigenere keyword` та повертати ненульове значення, як ми робили раніше. Якщо всі символи літерні, після перевірки ви маєте вивести `Success`, а потім вийти за допомогою `return 0;` одразу ж (на разі), оскільки наш шифруючий код ще не зовсім готовий до роботи, тож наша програма не буде його виконувати.

Приклад поведінки:

```
$ ./vigenere alpha
Success
```

або

```
$ ./vigenere 123
Usage: ./vigenere keyword
```

{% spoiler "Підказка" %}

* Пам’ятайте, що заголовковий файл `string.h` містить корисні функції, які працюють з рядками. Перегляньте меню [CCS50 Reference](https://reference.cs50.net/) аби довідатись про деякі з них!
* Пам’ятайте, що ми можемо використовувати цикл для ітерування через кожен символ рядка, якщо ми знаємо його довжину.
* Пам’ятайте, що заголовковий файл `ctype.h` містить корисні функції, які розповідають нам різні речі про символи. Перегляньте меню [CS50 Reference](https://reference.cs50.net/) аби довідатись про деякі з них!

{% endspoiler %}

{% next %}

## Одержання значення зсуву

Давайте на разі припустимо, що користувач надав односимвольні ключові слова. Чи можемо ми конвертувати цей символ на коректне значення зсуву? Давайте зробимо це, написавши _функцію_.
Нагорі вашого файлу, під рядками з `#include`, давайте _оголосимо_ _прототип_ для нової функції, метою якої буде робити виключно це. Вона буде приймати один символ на вхід та повертати значення зсуву для цього символу.

```
int shift(char c);
```
Тепер ми оголосили функцію `shift` яка приймає один символ (`c`) на вхід та повертає ціле число.

Нижче фігурної дужки, яка закриває `main`, давайте створимо для себе місце, аби _визначити_ (тобто імплементувати) цю нову функцію.

```
int shift(char c)
{
   // TODO
}
```

Місце, де знаходиться `TODO` i- це саме те місце, де ми будемо робити конвертацію символу на потрібне цілочисельне значення (знову ж, `A` чи `a` дають 0, `B` чи `b` дають 1, `Z` чи `z` дають 25, і т.д.)

Аби перевірити, видаліть рядки коду, де ви виводили `"Success"` (але залиште `return 0;` поки що), а на місці щойно видалених рядків додайте рядки подані нижче, які допоможуть перевірити, чи працює ваш код.

```
int key = shift(argv[1][0]);
printf("%i\n", key);
```

Ваша програма має вивести 0, якщо запустити її з ключовим словом `A` або `a`. Спробуйте запустити програму з іншими великими та малими літерами як ключовими словами. Вона поводиться саме так, як ви очікували?

{% spoiler "Підказка" %}

* Функції мають вхідні та вихідні дані.
* Коли ми *оголошуємо* функцію, потрібно задати тип значення, яке вона повертає, її ім’я та перелік аргументів, кожен з яких також має тип.
* Коли ми *використовуємо* або *викликаємо* функцію, ми просто передаємо підходящі значення до переліку аргументів та призначаємо вихідні дані функції змінній, яка має тип відповідний до типу поверненого функцією значення.
* Якщо `argv[1]` - це рядок, тоді `argv[1][0]` - це перший символ цього рядка.
* Пам’ятайте, що заголовковий файл `ctype.h` містить корисні функції, які можуть розповісти різні речі про символи.
* Значення ASCII для `A` - 65. Значення ASCII для `a` - 97.
* Значення ASCII для `B` - 66. Значення ASCII для `b` - 98. Помітили потенційну послідовність?

{% endspoiler %}

{% next %}

## Односимвольні ключові слова

Час повернутись до використання цього шифрувального коду, який ви написали! Ви мали помітити, що якщо ваше ключове слово _k_ містить точно одну літеру (скажімо, `H` або `h`), шифрування Вінежера успішно перетворюється на шифрування Цезаря (з кодом, у цьому прикладі, 7). Давайте на разі справді припустимо, що користувач надав односимвольне ключове слово. Використайте щойно створену функцію `shift` щоб підрахувати значення зсуву для поданої літери, призначте повернуте значення функції цілочисельній змінній `key`, та використайте `key` так само, як ви робили у шифруванні Цезаря! Все має звестись до простого видалення щойно доданого рядка `printf` та `return 0;` дозволивши програмі використати раніше написаний код шифрування Цезаря!

```
$ ./vigenere A
plaintext:  hello
ciphertext: hello
```

чи

```
$ ./vigenere b
plaintext:  HELLO
ciphertext: IFMMP
```

чи

```
$ ./vigenere C
plaintext:  HeLlO
ciphertext: JgNnQ
```

{% spoiler "Підказка" %}

Якщо деякі змінні у вашому розв’язку для Цезаря не збігаються з тим, як вони були названі у цьому середовищі, просто відредагуйте назви, аби вони збігались!

{% endspoiler %}

{% next %}

## Останні кроки

NТепер ваша черга перенести все, аби завершити імплементування функціональності, яка залишалась, до `vigenere.c`. Пам’ятайте, що ключове слово користувача, мабуть, міститиме кілька літер, тож вам потрібно обрахувати нове значення зсуву для кожної літери звичайного тексту, потім ви, можливо, захочете пересунути функцію `shift` якимось чином до циклу.

Пам’ятайте, що щоразу, коли ви шифруєте символ, ви маєте посуватись далі на наступну літеру в _k_, ключовому слові (і повернутись на початок ключового слова, якщо ви пройшли всіма його символами). Але якщо ви не зашифрували символ (тобто пробіл або пунктуаційний знак), не переходьте далі на наступний символ у _k_!

І, як і раніше, зберігайте регістр, але тільки спершись на оригінальне повідомлення. Велика чи маленька літера у ключовому слові не впливає на те, якою буде літера у зашифрованому тексті!

{% spoiler "Підказка" %}

* Вам, мабуть, знадобиться лічильник `i` для ітерації через звичайний текст та лічильник `j` для ітерації через ключове слово.
* Ви, мабуть, зрозумієте, що найпростіше контролювати лічильник для ключового слова самостійно, а не покладатись на цикл `for` який ви використаєте для ітерування через звичайний текст!
* Якщо довжина ключового слова, скажімо, 4 символи, тоді останній символ цього ключового слова можна знайти у `keyword[3]`. Тоді для наступного символу шифрування вам потрібно використовувати `keyword[0].`

{% endspoiler %}

## Перевірка

Для того, щоб перевірити правильність роботи програми виконайте команду
```
check50 cs50/problems/2018/x/vigenere
```
